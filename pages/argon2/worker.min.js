/**
 * @license
 * @very-amused/argon2-wasm v0.3.4
 * MIT License
 * Copyright (c) 2022 Keith Scroggs
 */
class e{constructor(e){this.worker=e,this.worker.addEventListener("message",(e=>{this.onMessage(e)}),!0)}onMessage(e){this.resolve&&this.resolve(e.data)}postMessage(e,r=[]){const t=new Promise((e=>{this.resolve=e}));return this.worker.postMessage(e,r),t}terminate(){this.worker.removeEventListener("message",(e=>{this.onMessage(e)}),!0),this.worker.terminate()}}var r;let t;!function(r){var t;r.WorkerConnection=e,(t=r.Methods||(r.Methods={}))[t.LoadArgon2=0]="LoadArgon2",t[t.Hash2i=1]="Hash2i",t[t.UnloadArgon2=2]="UnloadArgon2"}(r||(r={}));function o(e){return e instanceof Error?e.message:"string"==typeof e?e:"An unknown error has occured, and a message was unable to be parsed from this error"}const s=(e,r=[])=>{self.postMessage(e,r)};function a(e,r){for(let t=0;t<r.length;t++)e[t]=r[t]}function n(e,r=3){for(let t=0;t<r;t++)for(let r=0;r<e.length;r++)e[r]=0}async function i(e=".",r=!1,t=!1){if("object"!=typeof WebAssembly)throw 3;if(r&&(r=await async function(e="."){const r=await fetch(`${e}/simd-test.wasm`),t=await r.arrayBuffer();return WebAssembly.validate(t)}(e)),t&&(t="undefined"!=typeof SharedArrayBuffer),t){const t=`${e}/${`argon2${r?"-simd":""}-pthread.js`}`;importScripts(t);const o=new WebAssembly.Memory({initial:1024,maximum:65536,shared:!0}),s=await LoadArgon2Wasm({mainScriptUrlOrBlob:t,wasmMemory:o});return{malloc:s._malloc,free:s._free,argon2i_hash_raw:s._argon2i_hash_raw,memory:o}}{const t=`argon2${r?"-simd":""}.wasm`,o={env:{emscripten_notify_memory_growth(){}}};return(await WebAssembly.instantiateStreaming(fetch(`${e}/${t}`),o)).instance.exports}}onmessage=async function(e){(Array.isArray(e.data)||"object"!=typeof e.data)&&s({code:2});const c=e.data;switch(c.method){case r.Methods.LoadArgon2:try{const e=c.params;t=await i(e.wasmRoot,e.simd,e.pthread)}catch(e){return void function(e){console.error(e),s("number"==typeof e&&e>=-35&&e<=3?{code:e}:{code:1,message:o(e)})}(e)}s({code:0});break;case r.Methods.Hash2i:const e=function(e){const r=e.salt.byteLength,o=t.malloc(r);let s=new Uint8Array(t.memory.buffer,o,r);a(s,e.salt);const i=(new TextEncoder).encode(e.password),c=i.byteLength,m=t.malloc(c);let d=new Uint8Array(t.memory.buffer,m,c);a(d,i),n(i);const f=e.hashLen,h=t.malloc(f),y=t.argon2i_hash_raw(e.timeCost,e.memoryCost,1,m,c,o,r,h,f);d=new Uint8Array(t.memory.buffer,m,c),n(d),t.free(m),s=new Uint8Array(t.memory.buffer,o,r),n(s),t.free(o),n(e.salt);const l=new Uint8Array(f),w=new Uint8Array(t.memory.buffer,h,f);return a(l,w),n(w),t.free(h),{code:y,body:l}}(c.params);s({code:e.code,body:e.body},[e.body.buffer]);break;default:s({code:2})}};
